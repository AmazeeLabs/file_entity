<?php

/**
 * @file
 * Extends Drupal file entities to be fieldable and viewable.
 */

use Drupal\Component\Utility\Html;
use Drupal\Core\Database\Query\SelectInterface;
use Drupal\Core\Entity\EntityTypeInterface;
use Drupal\Core\Field\BaseFieldDefinition;
use Drupal\Core\Render\BubbleableMetadata;
use Drupal\Core\StreamWrapper\StreamWrapperInterface;
use Drupal\Core\Url;
use Drupal\file\Entity\File;
use Drupal\file\FileInterface;
use Drupal\file_entity\Entity\FileType;

/**
 * As part of extending Drupal core's file entity API, this module adds some
 * functions to the 'file' namespace. For organization, those are kept in the
 * 'file_entity.file_api.inc' file.
 */
require_once dirname(__FILE__) . '/file_entity.file_api.inc';

// @todo Remove when http://drupal.org/node/977052 is fixed.
require_once dirname(__FILE__) . '/file_entity.field.inc';

/**
 * Implements hook_hook_info().
 */
function file_entity_hook_info() {
  $hooks = array(
    'file_operations',
    'file_type_info',
    'file_type_info_alter',
    'file_formatter_info',
    'file_formatter_info_alter',
    'file_view',
    'file_view_alter',
    'file_displays_alter',
    'file_type',
    'file_type_alter',
    'file_download_headers_alter',
  );

  return array_fill_keys($hooks, array('group' => 'file'));
}

/**
 * Implements hook_hook_info_alter().
 *
 * Add support for existing core hooks to be located in modulename.file.inc.
 */
function file_entity_hook_info_alter(&$info) {
  $hooks = array(
    // File API hooks
    'file_copy',
    'file_move',
    'file_validate',
    // File access
    'file_download',
    'file_download_access',
    'file_download_access_alter',
    // File entity hooks
    'file_load',
    'file_presave',
    'file_insert',
    'file_update',
    'file_delete',
    // Miscellaneous hooks
    'file_mimetype_mapping_alter',
    'file_url_alter',
  );
  $info += array_fill_keys($hooks, array('group' => 'file'));
}

/**
 * Implements hook_help().
 */
function file_entity_help($path, $arg) {
  switch ($path) {
    case 'admin/structure/file-types':
      $output = '<p>' . t('When a file is uploaded to this website, it is assigned one of the following types, based on what kind of file it is.') . '</p>';
      return $output;
    case 'admin/structure/file-types/manage/%/display/preview':
    case 'admin/structure/file-types/manage/%/file-display/preview':
      drupal_set_message(t('Some modules rely on the Preview view mode to function correctly. Changing these settings may break parts of your site.'), 'warning');
      break;
  }
}

/**
 * Implements hook_menu().
 */
function file_entity_menu() {
//   File Configuration
//   @todo Move this back to admin/config/media/file-types in Drupal 8 if
//   MENU_MAX_DEPTH is increased to a value higher than 9.
  $items['admin/structure/file-types/manage/%file_type'] = array(
    'title' => 'Manage file types',
    'description' => 'Manage settings for the type of files used on your site.',
  );

  $items['file/add/upload/file'] = array(
    'title' => 'File',
    'type' => MENU_DEFAULT_LOCAL_TASK,
    'weight' => -10,
  );
  $items['file/add/upload/archive'] = array(
    'title' => 'Archive',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('file_entity_upload_archive_form'),
    'access arguments' => array('administer files'),
    'file' => 'file_entity.pages.inc',
    'type' => MENU_LOCAL_TASK,
    'weight' => -5,
  );

  // Attach a "Manage file display" tab to each file type in the same way that
  // Field UI attaches "Manage fields" and "Manage display" tabs. Note that
  // Field UI does not have to be enabled; we're just using the same IA pattern
  // here for attaching the "Manage file display" page.
  $bundles = \Drupal::entityManager()->getBundleInfo('file');
  foreach ($bundles as $file_type => $bundle_info) {
    if (isset($bundle_info['admin'])) {
      // Get the base path and access.
      $path = $bundle_info['admin']['path'];
      $access = array_intersect_key($bundle_info['admin'], array('access callback' => NULL, 'access argument' => NULL));
      $access += array(
        'access callback' => 'user_access',
        'access arguments' => array('administer file types'),
      );

      // The file type must be passed to the page callbacks. It might be
      // configured as a wildcard (multiple file types sharing the same menu
      // router path).
      $file_type_argument = isset($bundle_info['admin']['bundle argument']) ? $bundle_info['admin']['bundle argument'] : $file_type;

      $items[$path] = array(
        'title' => 'Edit file type',
        'title callback' => 'file_entity_type_get_name',
        'title arguments' => array(4),
        'page callback' => 'drupal_get_form',
        'page arguments' => array('file_entity_file_type_form', $file_type_argument),
        'file' => 'file_entity.admin.inc',
      ) + $access;

      // Add the 'File type settings' tab.
      $items["$path/edit"] = array(
        'title' => 'Edit',
        'type' => MENU_DEFAULT_LOCAL_TASK,
      );

      // Add the 'Manage file display' tab.
      $items["$path/file-display"] = array(
        'title' => 'Manage file display',
        'page callback' => 'drupal_get_form',
        'page arguments' => array('file_entity_file_display_form', $file_type_argument, 'default'),
        'type' => MENU_LOCAL_TASK,
        'weight' => 3,
        'file' => 'file_entity.admin.inc',
      ) + $access;

      // Add a secondary tab for each view mode.
      $weight = 0;
      $view_modes = array('default' => array('label' => t('Default'))) + $entity_info['view modes'];
      foreach ($view_modes as $view_mode => $view_mode_info) {
        $items["$path/file-display/$view_mode"] = array(
          'title' => $view_mode_info['label'],
          'page arguments' => array('file_entity_file_display_form', $file_type_argument, $view_mode),
          'type' => ($view_mode == 'default' ? MENU_DEFAULT_LOCAL_TASK : MENU_LOCAL_TASK),
          'weight' => ($view_mode == 'default' ? -10 : $weight++),
          'file' => 'file_entity.admin.inc',
          // View modes for which the 'custom settings' flag isn't TRUE are
          // disabled via this access callback. This needs to extend, rather
          // than override normal $access rules.
          'access callback' => '_file_entity_view_mode_menu_access',
          'access arguments' => array_merge(array($file_type_argument, $view_mode, $access['access callback']), $access['access arguments']),
        );
      }
    }
  }

  // Optional devel module integration
  if (\Drupal::moduleHandler()->moduleExists('devel')) {
    $items['file/%file/devel'] = array(
      'title' => 'Devel',
      'page callback' => 'devel_load_object',
      'page arguments' => array('file', 1),
      'access arguments' => array('access devel information'),
      'type' => MENU_LOCAL_TASK,
      'file' => 'devel.pages.inc',
      'file path' => drupal_get_path('module', 'devel'),
      'weight' => 100,
    );
    $items['file/%file/devel/load'] = array(
      'title' => 'Load',
      'type' => MENU_DEFAULT_LOCAL_TASK,
    );
    $items['file/%file/devel/render'] = array(
      'title' => 'Render',
      'page callback' => 'devel_render_object',
      'page arguments' => array('file', 1),
      'access arguments' => array('access devel information'),
      'file' => 'devel.pages.inc',
      'file path' => drupal_get_path('module', 'devel'),
      'type' => MENU_LOCAL_TASK,
      'weight' => 100,
    );
    if (\Drupal::moduleHandler()->moduleExists('token')) {
      $items['file/%file/devel/token'] = array(
        'title' => 'Tokens',
        'page callback' => 'token_devel_token_object',
        'page arguments' => array('file', 1),
        'access arguments' => array('access devel information'),
        'type' => MENU_LOCAL_TASK,
        'file' => 'token.pages.inc',
        'file path' => drupal_get_path('module', 'token'),
        'weight' => 5,
      );
    }
  }

  return $items;
}

/**
 * Gather the rankings from the the hook_ranking implementations.
 *
 * @param $query
 *   A query object that has been extended with the Search DB Extender.
 */
function _file_entity_rankings(SelectQueryExtender $query) {
  if ($ranking = \Drupal::moduleHandler()->invokeAll('file_ranking')) {
    $tables = &$query->getTables();
    foreach ($ranking as $rank => $values) {
      if ($file_rank = \Drupal::config('file_entity.settings')->get('rank_' . $rank, 0)) {
        // If the table defined in the ranking isn't already joined, then add it.
        if (isset($values['join']) && !isset($tables[$values['join']['alias']])) {
          $query->addJoin($values['join']['type'], $values['join']['table'], $values['join']['alias'], $values['join']['on']);
        }
        $arguments = isset($values['arguments']) ? $values['arguments'] : array();
        $query->addScore($values['score'], $arguments, $file_rank);
      }
    }
  }
}

/**
 * Implements hook_action_info_alter().
 */
function file_entity_action_info_alter(&$actions) {
  if (\Drupal::moduleHandler()->moduleExists('pathauto')) {
    $actions['pathauto_file_update_action'] = array(
      'type' => 'file',
      'label' => t('Update file alias'),
      'configurable' => FALSE,
    );
  }
}

/**
 * Implements hook_theme().
 */
function file_entity_theme() {
  return array(
    'file' => array(
      'render element' => 'elements',
      'template' => 'file',
    ),
    'file_entity_file_type_overview' => array(
      'variables' => array('label' => NULL, 'description' => NULL),
      'file' => 'file_entity.admin.inc',
    ),
    'file_entity_file_display_order' => array(
      'render element' => 'element',
      'file' => 'file_entity.admin.inc',
    ),
    'file_entity_file_link' => array(
      'variables' => array('file' => NULL, 'icon_directory' => NULL),
      'file' => 'file_entity.theme.inc',
    ),
    'file_entity_download_link' => array(
      'variables' => array('file' => NULL, 'icon_directory' => NULL, 'text' => NULL),
      'file' => 'file_entity.theme.inc',
    ),
    'file_entity_file_audio' => array(
      'variables' => array(
        'files' => array(),
        'controls' => TRUE,
        'autoplay' => FALSE,
        'loop' => FALSE,
      ),
      'file' => 'file_entity.theme.inc',
    ),
    'file_entity_file_video' => array(
      'variables' => array(
        'files' => array(),
        'controls' => TRUE,
        'autoplay' => FALSE,
        'loop' => FALSE,
        'muted' => FALSE,
        'width' => NULL,
        'height' => NULL,
      ),
      'file' => 'file_entity.theme.inc',
    ),
  );
}

/**
 * Implements hook_entity_info_alter().
 *
 * Extends the core file entity to be fieldable. The file type is used as the
 * bundle key.
 */
function file_entity_entity_type_alter(&$entity_types) {
  /** @var $entity_types \Drupal\Core\Entity\EntityTypeInterface[] */
  $keys = $entity_types['file']->getKeys();
  $keys['bundle'] = 'type';
  $entity_types['file']
    ->set('entity_keys', $keys)
    ->set('bundle_entity_type', 'file_type')
    ->set('admin_permission', 'administer files')
    ->setClass('Drupal\file_entity\Entity\FileEntity')
    ->setHandlerClass('storage_schema', 'Drupal\file_entity\FileEntityStorageSchema')
    ->setFormClass('default', 'Drupal\file_entity\Form\FileEditForm')
    ->setFormClass('edit', 'Drupal\file_entity\Form\FileEditForm')
    ->setFormClass('inline_edit', 'Drupal\file_entity\Form\FileInlineEditForm')
    ->setFormClass('delete', 'Drupal\Core\Entity\ContentEntityDeleteForm')
    ->setAccessClass('Drupal\file_entity\FileEntityAccessControlHandler')
    ->set('field_ui_base_route', 'entity.file_type.edit_form')
    ->setLinkTemplate('canonical', '/file/{file}')
    ->setLinkTemplate('collection', '/admin/content/files')
    ->setLinkTemplate('edit-form', '/file/{file}/edit')
    ->setLinkTemplate('delete-form', '/file/{file}/delete')
    ->setLinkTemplate('inline-edit-form', '/file/{file}/inline-edit')
    ->setViewBuilderClass('Drupal\file_entity\Entity\FileEntityViewBuilder')
    ->setListBuilderClass('Drupal\Core\Entity\EntityListBuilder');

  /*$entity_types['file']['view modes']['teaser'] = array(
    'label' => t('Teaser'),
    'custom settings' => TRUE,
  );
  $entity_types['file']['view modes']['full'] = array(
    'label' => t('Full content'),
    'custom settings' => FALSE,
  );
  $entity_types['file']['view modes']['preview'] = array(
    'label' => t('Preview'),
    'custom settings' => TRUE,
  );
  $entity_types['file']['view modes']['rss'] = array(
    'label' => t('RSS'),
    'custom settings' => FALSE,
  );*/

  // Enable Metatag support.
  //$entity_types['file']['metatags'] = TRUE;
}

/**
 * Entity API callback to get the form of a file entity.
 */
function file_entity_metadata_form_file($file) {
  // Pre-populate the form-state with the right form include.
  $form_state['build_info']['args'] = array($file);
  form_load_include($form_state, 'inc', 'file_entity', 'file_entity.pages');
  return drupal_build_form('file_entity_edit', $form_state);
}

/**
 * Implements hook_file_formatter_info().
 */
function file_entity_file_formatter_info() {
  $formatters = array();

  // Allow file field formatters to be reused for displaying the file entity's
  // file pseudo-field.
  foreach (field_info_formatter_types() as $key => $formatter) {
    if (array_intersect($formatter['field types'], array('file', 'image'))) {
      $key = 'file_field_' . $key;
      $formatters[$key] = array(
        'label' => $formatter['label'],
        'description' => !empty($formatter['description']) ? $formatter['description'] : '',
        'view callback' => 'file_entity_file_formatter_file_field_view',
      );
      if (!empty($formatter['settings'])) {
        $formatters[$key] += array(
          'default settings' => $formatter['settings'],
          'settings callback' => 'file_entity_file_formatter_file_field_settings',
        );
      }
      if (!empty($formatter['file formatter'])) {
        $formatters[$key] += $formatter['file formatter'];
      }
    }
  }

  // Add a simple file formatter for displaying an image in a chosen style.
  if (\Drupal::moduleHandler()->moduleExists('image')) {
    $formatters['file_image'] = array(
      'label' => t('Image'),
      'default settings' => array(
        'image_style' => '',
        'alt' => '[file:field_file_image_alt_text]',
        'title' => '[file:field_file_image_title_text]'
      ),
      'view callback' => 'file_entity_file_formatter_file_image_view',
      'settings callback' => 'file_entity_file_formatter_file_image_settings',
      'hidden' => TRUE,
      'mime types' => array('image/*'),
    );
  }

  return $formatters;
}

/**
 * Implements hook_file_formatter_FORMATTER_view().
 *
 * This function provides a bridge to the field formatter API, so that file
 * field formatters can be reused for displaying the file entity's file
 * pseudo-field.
 */
function file_entity_file_formatter_file_field_view($file, $display, $langcode) {
  if (strpos($display['type'], 'file_field_') === 0) {
    $field_formatter_type = substr($display['type'], strlen('file_field_'));
    $field_formatter_info = field_info_formatter_types($field_formatter_type);
    if (isset($field_formatter_info['module'])) {
      // Set $display['type'] to what hook_field_formatter_*() expects.
      $display['type'] = $field_formatter_type;

      // Set $items to what file field formatters expect. See file_field_load(),
      // and note that, here, $file is already a fully loaded entity.
      $items = array((array) $file);

      // Invoke hook_field_formatter_prepare_view() and
      // hook_field_formatter_view(). Note that we are reusing field formatter
      // functions, but we are not displaying a Field API field, so we set
      // $field and $instance accordingly, and do not invoke
      // hook_field_prepare_view(). This assumes that the formatter functions do
      // not rely on $field or $instance. A module that implements formatter
      // functions that rely on $field or $instance (and therefore, can only be
      // used for real fields) can prevent this formatter from being used on the
      // pseudo-field by removing it within hook_file_formatter_info_alter().
      $field = $instance = NULL;
      if (($function = ($field_formatter_info['module'] . '_field_formatter_prepare_view')) && function_exists($function)) {
        $fid = $file->fid;
        // hook_field_formatter_prepare_view() alters $items by reference.
        $grouped_items = array($fid => &$items);
        $function('file', array($fid => $file), $field, array($fid => $instance), $langcode, $grouped_items, array($fid => $display));
      }
      if (($function = ($field_formatter_info['module'] . '_field_formatter_view')) && function_exists($function)) {
        $element = $function('file', $file, $field, $instance, $langcode, $items, $display);
        // We passed the file as $items[0], so return the corresponding element.
        if (isset($element[0])) {
          return $element[0];
        }
      }
    }
  }
}

/**
 * Implements hook_file_formatter_FORMATTER_settings().
 *
 * This function provides a bridge to the field formatter API, so that file
 * field formatters can be reused for displaying the file entity's file
 * pseudo-field.
 */
function file_entity_file_formatter_file_field_settings($form, &$form_state, $settings, $formatter_type, $file_type, $view_mode) {
  if (strpos($formatter_type, 'file_field_') === 0) {
    $field_formatter_type = substr($formatter_type, strlen('file_field_'));
    $field_formatter_info = field_info_formatter_types($field_formatter_type);

    // Invoke hook_field_formatter_settings_form(). We are reusing field
    // formatter functions, but we are not working with a Field API field, so
    // set $field accordingly. Unfortunately, the API is for $settings to be
    // transfered via the $instance parameter, so we must mock it.
    if (isset($field_formatter_info['module']) && ($function = ($field_formatter_info['module'] . '_field_formatter_settings_form')) && function_exists($function)) {
      $field = NULL;
      $mock_instance = array(
        'display' => array(
          $view_mode => array(
            'type' => $field_formatter_type,
            'settings' => $settings,
          ),
        ),
        'entity_type' => 'file',
        'bundle' => $file_type,
      );
      return $function($field, $mock_instance, $view_mode, $form, $form_state);
    }
  }
}

/**
 * Implements hook_file_formatter_FORMATTER_view().
 *
 * Returns a drupal_render() array to display an image of the chosen style.
 *
 * This formatter is only capable of displaying local images. If the passed in
 * file is either not local or not an image, nothing is returned, so that
 * file_view_file() can try another formatter.
 */
function file_entity_file_formatter_file_image_view($file, $display, $langcode) {
  // Prevent PHP notices when trying to read empty files.
  // @see http://drupal.org/node/681042
  if (!$file->filesize) {
    return;
  }

  // Do not bother proceeding if this file does not have an image mime type.
  if (file_entity_file_get_mimetype_type($file) != 'image') {
    return;
  }

  if (file_entity_file_is_readable($file)) {
    // We don't sanitize here.
    // @see http://drupal.org/node/1553094#comment-6257382
    // Theme function will take care of escaping.
    if (!isset($file->metadata)) {
      $file->metadata = array();
    }
    $file->metadata += array('width' => NULL, 'height' => NULL);
    $replace_options = array(
      'clear' => TRUE,
      'sanitize' => FALSE,
    );
    if (!empty($display['settings']['image_style'])) {
      $element = array(
        '#theme' => 'image_style',
        '#style_name' => $display['settings']['image_style'],
        '#path' => $file->uri,
        '#width' => isset($file->override['attributes']['width']) ? $file->override['attributes']['width'] : $file->metadata['width'],
        '#height' => isset($file->override['attributes']['height']) ? $file->override['attributes']['height'] : $file->metadata['height'],
        '#alt' => token_replace($display['settings']['alt'], array('file' => $file), $replace_options),
        '#title' => token_replace($display['settings']['title'], array('file' => $file), $replace_options),
      );
    }
    else {
      $element = array(
        '#theme' => 'image',
        '#path' => $file->uri,
        '#width' => isset($file->override['attributes']['width']) ? $file->override['attributes']['width'] : $file->metadata['width'],
        '#height' => isset($file->override['attributes']['height']) ? $file->override['attributes']['height'] : $file->metadata['height'],
        '#alt' => token_replace($display['settings']['alt'], array('file' => $file), $replace_options),
        '#title' => token_replace($display['settings']['title'], array('file' => $file), $replace_options),
      );
    }
    return $element;
  }
}

/**
 * Check if a file entity is readable or not.
 *
 * @param object $file
 *   A file entity object from file_load().
 *
 * @return boolean
 *   TRUE if the file is using a readable stream wrapper, or FALSE otherwise.
 */
function file_entity_file_is_readable($file) {
  $scheme = file_uri_scheme($file->uri);
  $wrappers = \Drupal::service('stream_wrapper_manager')->getWrappers(StreamWrapperInterface::READ);
  return !empty($wrappers[$scheme]);
}

/**
 * Implements hook_file_formatter_FORMATTER_settings().
 *
 * Returns form elements for configuring the 'file_image' formatter.
 */
function file_entity_file_formatter_file_image_settings($form, &$form_state, $settings) {
  $element = array();
  $element['image_style'] = array(
    '#title' => t('Image style'),
    '#type' => 'select',
    '#options' => image_style_options(FALSE),
    '#default_value' => $settings['image_style'],
    '#empty_option' => t('None (original image)'),
  );

  // For image files we allow the alt attribute (required in HTML).
  $element['alt'] = array(
    '#title' => t('Alt attribute'),
    '#description' => t('The text to use as value for the <em>img</em> tag <em>alt</em> attribute.'),
    '#type' => 'textfield',
    '#default_value' => $settings['alt'],
  );

  // Allow the setting of the title attribute.
  $element['title'] = array(
    '#title' => t('Title attribute'),
    '#description' => t('The text to use as value for the <em>img</em> tag <em>title</em> attribute.'),
    '#type' => 'textfield',
    '#default_value' => $settings['title'],
  );

  if (\Drupal::moduleHandler()->moduleExists('token')) {
    $element['alt']['#description'] .= t('This field supports tokens.');
    $element['title']['#description'] .= t('This field supports tokens.');
    $element['tokens'] = array(
      '#theme' => 'token_tree',
      '#token_types' => array('file'),
      '#dialog' => TRUE,
    );
  }

  return $element;
}

/**
 * Menu access callback for the 'view mode file display settings' pages.
 *
 * Based on _field_ui_view_mode_menu_access(), but the Field UI module might not
 * be enabled.
 */
function _file_entity_view_mode_menu_access($file_type, $view_mode, $access_callback) {
  // Deny access if the view mode isn't configured to use custom display
  // settings.
  $view_mode_settings = field_view_mode_settings('file', $file_type->type);
  $visibility = ($view_mode == 'default') || !empty($view_mode_settings[$view_mode]['custom_settings']);
  if (!$visibility) {
    return FALSE;
  }

  // Otherwise, continue to an $access_callback check.
  $args = array_slice(func_get_args(), 3);
  $callback = empty($access_callback) ? 0 : trim($access_callback);
  if (is_numeric($callback)) {
    return (bool) $callback;
  }
  elseif (function_exists($access_callback)) {
    return call_user_func_array($access_callback, $args);
  }
}

/**
 * Implements hook_modules_enabled().
 */
function file_entity_modules_enabled($modules) {
  file_info_cache_clear();
}

/**
 * Implements hook_modules_disabled().
 */
function file_entity_modules_disabled($modules) {
  file_info_cache_clear();
}

/**
 * Returns whether the current page is the full page view of the passed-in file.
 *
 * @param $file
 *   A file object.
 */
function file_entity_is_page($file) {
  $page_file = \Drupal::routeMatch()->getParameter('file');
  return !empty($page_file) && $page_file->id() == $file->id();
}

/**
 * Prepares variables for file templates.
 *
 * Default template: file.html.twig.
 *
 * @param array $variables
 *   An associative array containing:
 *   - elements: An array of elements to display in view mode.
 *   - file: The file object.
 */
function template_preprocess_file(&$variables) {
  $view_mode = $variables['view_mode'] = $variables['elements']['#view_mode'];
  $variables['file'] = $variables['elements']['#file'];

  /** @var FileInterface $file */
  $file = $variables['file'];

  $variables['id']        = $file->id();
  $variables['date']      = format_date($file->getCreatedTime()); // @TODO: Check this out
  $username = array(
    '#theme' => 'username',
    '#account' => $file->getOwner(),
    '#link_options' => array('attributes' => array('rel' => 'author')),
  );
  $variables['name']      = drupal_render($username);

  $variables['file_url']  = $file->url('canonical');
  $label                  = $file->label();
  $variables['label']     = \Drupal\Component\Utility\SafeMarkup::checkPlain($label);
  $variables['page']      = $view_mode == 'full' && file_entity_is_page($file);

  // Hide the file name from being displayed until we can figure out a better
  // way to control this. We cannot simply not output the title since
  // contextual links require $title_suffix to be output in the template.
  // @see http://drupal.org/node/1245266
  if (!$variables['page']) {
    $variables['title_attributes_array']['class'][] = 'element-invisible';
  }

  // Flatten the file object's member fields.
  $variables = array_merge((array) $file, $variables);

  // Helpful $content variable for templates.
  $variables += array('content' => array());
  foreach (\Drupal\Core\Render\Element::children($variables['elements']) as $key) {
    $variables['content'][$key] = $variables['elements'][$key];
  }

  // Make the field variables available with the appropriate language.
  //field_attach_preprocess('file', $file, $variables['content'], $variables);

  // Attach the file object to the content element.
  $variables['content']['file']['#file'] = $file;

  // Display post information only on certain file types.
  //if (variable_get('file_submitted_' . $file->type, FALSE)) { @TODO: What todo with this?
  if (FALSE) {
    $variables['display_submitted'] = TRUE;
    $variables['submitted'] = t('Uploaded by @username on @datetime', array('@username' => $variables['name'], '@datetime' => $variables['date']));
    $variables['user_picture'] = theme_get_setting('toggle_file_user_picture') ? theme('user_picture', array('account' => $account)) : '';
  }
  else {
    $variables['display_submitted'] = FALSE;
    $variables['submitted'] = '';
    $variables['user_picture'] = '';
  }

  // Gather file classes.
  $variables['classes_array'][] = Html::getClass('file-' . $file->bundle());
  $variables['classes_array'][] = Html::getClass('file-' . $file->getMimeType());
  if (!$file->isPermanent()) {
    $variables['classes_array'][] = 'file-temporary';
  }

  // Change the 'file-entity' class into 'file'
  if ($variables['classes_array'][0] == 'file-entity') {
    $variables['classes_array'][0] = 'file';
  }
}

/**
 * Implements hook_theme_suggestions_HOOK_alter().
 */
function file_entity_theme_suggestions_file_alter(array &$suggestions, array $variables) {
  $view_mode = $variables['view_mode'] = $variables['elements']['#view_mode'];

  /** @var FileInterface $file */
  $file = $variables['elements']['#file'];

  // Clean up name so there are no underscores.
  $suggestions[] = 'file__' . $file->bundle();
  $suggestions[] = 'file__' . $file->bundle() . '__' . $view_mode;
  $suggestions[] = 'file__' . str_replace(array('/', '-'), array('__', '_'), $file->getMimeType());
  $suggestions[] = 'file__' . str_replace(array('/', '-'), array('__', '_'), $file->getMimeType()) . '__' . $view_mode;
  $suggestions[] = 'file__' . $file->id();
  $suggestions[] = 'file__' . $file->id() . '__' . $view_mode;
}

/**
 * Returns the file type name of the passed file or file type string.
 *
 * @param $file
 *   A file object or string that indicates the file type to return.
 *
 * @return
 *   The file type name or FALSE if the file type is not found.
 */
function file_entity_type_get_name(FileInterface $file) {
  $type = is_object($file) ? $file->type : $file;
  $info = entity_get_info('file');
  return isset($info['bundles'][$type]['label']) ? $info['bundles'][$type]['label'] : FALSE;
}

/**
 * Returns a list of available file type names.
 *
 * @return
 *   An array of file type names, keyed by the type.
 */
function file_entity_type_get_names() {
  $names = &drupal_static(__FUNCTION__);
  if (!isset($names)) {
    foreach (FileType::loadMultiple() as $id => $type) {
      $names[$id] = $type->label();
    }
  }
  return $names;
}

/**
 * Return the label for a specific file entity view mode.
 */
function file_entity_view_mode_label($view_mode, $default = FALSE) {
  $labels = \Drupal::entityManager()->getViewModeOptions('file');
  return isset($labels[$view_mode]) ? $labels[$view_mode] : $default;
}

/**
 * Return a specific stream wrapper's registry information.
 *
 * @param $scheme
 *   A URI scheme, a stream is referenced as "scheme://target".
 *
 * @see file_get_stream_wrappers()
 */
function file_entity_get_stream_wrapper($scheme) {
  $wrappers = file_get_stream_wrappers();
  return isset($wrappers[$scheme]) ? $wrappers[$scheme] : FALSE;
}

/**
 * Implements hook_ctools_plugin_api().
 */
function file_entity_ctools_plugin_api($owner, $api) {
  if ($owner == 'file_entity' && $api == 'file_type') {
    return array('version' => 1);
  }
  if ($owner == 'file_entity' && $api == 'file_default_displays') {
    return array('version' => 1);
  }
}

/**
 * @defgroup file_entity_access File access rights
 * @{
 * The file access system determines who can do what to which files.
 *
 * In determining access rights for a file, file_entity_access() first checks
 * whether the user has the "bypass file access" permission. Such users have
 * unrestricted access to all files. user 1 will always pass this check.
 *
 * Next, all implementations of hook_file_entity_access() will be called. Each
 * implementation may explicitly allow, explicitly deny, or ignore the access
 * request. If at least one module says to deny the request, it will be rejected.
 * If no modules deny the request and at least one says to allow it, the request
 * will be permitted.
 *
 * There is no access grant system for files.
 *
 * In file listings, the process above is followed except that
 * hook_file_entity_access() is not called on each file for performance reasons
 * and for proper functioning of the pager system. When adding a filelisting to
 * your module, be sure to use a dynamic query created by db_select()
 * and add a tag of "file_entity_access". This will allow modules dealing
 * with file access to ensure only files to which the user has access
 * are retrieved, through the use of hook_query_TAG_alter().
 *
 * Note: Even a single module returning FILE_ENTITY_ACCESS_DENY from
 * hook_file_entity_access() will block access to the file. Therefore,
 * implementers should take care to not deny access unless they really intend to.
 * Unless a module wishes to actively deny access it should return
 * FILE_ENTITY_ACCESS_IGNORE (or simply return nothing)
 * to allow other modules to control access.
 *
 * Stream wrappers that are considered private should implement a 'private'
 * flag equal to TRUE in hook_stream_wrappers().
 */

/**
 * Implements hook_query_TAG_alter().
 *
 * This is the hook_query_alter() for queries tagged with 'file_access'. It adds
 * file access checks for the user account given by the 'account' meta-data (or
 * global $user if not provided).
 */
function file_entity_query_file_access_alter(SelectInterface $query) {
  _file_entity_query_file_entity_access_alter($query, 'file');
}

/**
 * Helper for file entity access functions.
 *
 * @param $query
 *   The query to add conditions to.
 * @param $type
 *   Either 'file' or 'entity' depending on what sort of query it is. See
 *   file_entity_query_file_entity_access_alter() and
 *   file_entity_query_entity_field_access_alter() for more.
 */
function _file_entity_query_file_entity_access_alter($query, $type) {
  $user = \Drupal::currentUser();

  // Read meta-data from query, if provided.
  if (!$account = $query->getMetaData('account')) {
    $account = $user;
  }

  // If $account can bypass file access, we don't need to alter the query.
  if ($account->hasPermission('bypass file access')) {
    return;
  }

  $tables = $query->getTables();
  $base_table = $query->getMetaData('base_table');
  // If no base table is specified explicitly, search for one.
  if (!$base_table) {
    $fallback = '';
    foreach ($tables as $alias => $table_info) {
      if (!($table_info instanceof SelectInterface)) {
        $table = $table_info['table'];
        // If the file_managed table is in the query, it wins immediately.
        if ($table == 'file_managed') {
          $base_table = $table;
          break;
        }
        // Check whether the table has a foreign key to file_managed.fid. If it
        // does, do not run this check again as we found a base table and only
        // file_managed can triumph that.
        if (!$base_table) {
          // The schema is cached.
          $schema = drupal_get_schema($table);
          if (isset($schema['fields']['fid'])) {
            if (isset($schema['foreign keys'])) {
              foreach ($schema['foreign keys'] as $relation) {
                if ($relation['table'] === 'file_managed' && $relation['columns'] === array('fid' => 'fid')) {
                  $base_table = $table;
                }
              }
            }
            else {
              // At least it's a fid. A table with a field called fid is very
              // very likely to be a file_managed.fid in a file access query.
              $fallback = $table;
            }
          }
        }
      }
    }
    // If there is nothing else, use the fallback.
    if (!$base_table) {
      if ($fallback) {
        watchdog('security', 'Your file listing query is using @fallback as a base table in a query tagged for file access. This might not be secure and might not even work. Specify foreign keys in your schema to file_managed.fid ', array('@fallback' => $fallback), WATCHDOG_WARNING);
        $base_table = $fallback;
      }
      else {
        throw new Exception(t('Query tagged for file access but there is no fid. Add foreign keys to file_managed.fid in schema to fix.'));
      }
    }
  }

  if ($type == 'entity') {
    // The original query looked something like:
    // @code
    //  SELECT fid FROM sometable s
    //  WHERE ($file_access_conditions)
    // @endcode
    //
    // Our query will look like:
    // @code
    //  SELECT entity_type, entity_id
    //  FROM field_data_something s
    //  WHERE (entity_type = 'file' AND $file_access_conditions) OR (entity_type <> 'file')
    // @endcode
    //
    // So instead of directly adding to the query object, we need to collect
    // all of the file access conditions in a separate db_and() object and
    // then add it to the query at the end.
    $file_conditions = db_and();
  }
  foreach ($tables as $falias => $tableinfo) {
    $table = $tableinfo['table'];
    if (!($table instanceof SelectInterface) && $table == $base_table) {
      $subquery = db_select('file_managed', 'fm_access')->fields('fm_access', array('fid'));
      $subquery_conditions = db_or();

      $wrappers = file_entity_get_public_and_private_stream_wrapper_names();
      if (!empty($wrappers['public'])) {
        if ($account->hasPermission('view files')) {
          foreach (array_keys($wrappers['public']) as $wrapper) {
            $subquery_conditions->condition('fm_access.uri', $wrapper . '%', 'LIKE');
          }
        }
        elseif ($account->hasPermission('view own files')) {
          foreach (array_keys($wrappers['public']) as $wrapper) {
            $subquery_conditions->condition(db_and()
              ->condition('fm_access.uri', $wrapper . '%', 'LIKE')
              ->condition('fm_access.uid', $account->id())
            );
          }
        }
      }
      if (!empty($wrappers['private'])) {
        if ($account->hasPermission('view private files')) {
          foreach (array_keys($wrappers['private']) as $wrapper) {
            $subquery_conditions->condition('fm_access.uri', $wrapper . '%', 'LIKE');
          }
        }
        elseif ($account->hasPermission('view own private files')) {
          foreach (array_keys($wrappers['private']) as $wrapper) {
            $subquery_conditions->condition(db_and()
              ->condition('fm_access.uri', $wrapper . '%', 'LIKE')
              ->condition('fm_access.uid', $account->id())
            );
          }
        }
      }

      if ($subquery_conditions->count()) {
        $subquery->condition($subquery_conditions);

        $field = 'fid';
        // Now handle entities.
        if ($type == 'entity') {
          // Set a common alias for entities.
          $base_alias = $falias;
          $field = 'entity_id';
        }
        $subquery->where("$falias.$field = fm_access.fid");

        // For an entity query, attach the subquery to entity conditions.
        if ($type == 'entity') {
          $file_conditions->exists($subquery);
        }
        // Otherwise attach it to the node query itself.
        elseif ($table == 'file_managed') {
          // Fix for https://drupal.org/node/2073085
          $db_or = db_or();
          $db_or->exists($subquery);
          $db_or->isNull($falias . '.' . $field);
          $query->condition($db_or);
        }
        else {
          $query->exists($subquery);
        }
      }
    }
  }

  if ($type == 'entity' && $file_conditions->count()) {
    // All the file access conditions are only for field values belonging to
    // files.
    $file_conditions->condition("$base_alias.entity_type", 'file');
    $or = db_or();
    $or->condition($file_conditions);
    // If the field value belongs to a non-file entity type then this function
    // does not do anything with it.
    $or->condition("$base_alias.entity_type", 'file', '<>');
    // Add the compiled set of rules to the query.
    $query->condition($or);
  }
}

/**
 * Implements hook_file_download().
 */
function file_entity_file_download($uri) {
  // Load the file from the URI.
  $file = file_uri_to_object($uri);

  // An existing file wasn't found, so we don't control access.
  // E.g. image derivatives will fall here.
  if (empty($file)) {
    return NULL;
  }

  // Allow the user to download the file if they have appropriate permissions.
  if ($file->access('view')) {
    return file_get_content_headers($file);
  }

  return -1;
}

/**
 * @} End of "defgroup file_entity_access".
 */

/**
 * Implements hook_file_operations().
 */
function file_entity_file_operations() {
  $operations = array(
    'permanent' => array(
      'label' => t('Indicate that the selected files are permanent and should not be deleted'),
      'callback' => 'file_entity_mass_update',
      'callback arguments' => array('updates' => array('status' => FILE_STATUS_PERMANENT)),
    ),
    'temporary' => array(
      'label' => t('Indicate that the selected files are temporary and should be removed during cron runs'),
      'callback' => 'file_entity_mass_update',
      'callback arguments' => array('updates' => array('status' => 0)),
    ),
    'delete' => array(
      'label' => t('Delete selected files'),
      'callback' => NULL,
    ),
  );
  return $operations;
}

/**
 * Clear the field cache for any entities referencing a specific file.
 *
 * @param object $file
 *   A file object.
 */
function file_entity_invalidate_field_caches($file) {
  $entity_types = &drupal_static(__FUNCTION__);

  // Gather the list of entity types which support field caching.
  if (!isset($entity_types)) {
    $entity_types = array();
    foreach (entity_get_info() as $entity_type => $entity_info) {
      if (!empty($entity_info['fieldable']) && !empty($entity_info['field cache'])) {
        $entity_types[] = $entity_type;
      }
    }
  }

  // If no entity types support field caching, then there is no work to be done.
  if (empty($entity_types)) {
    return;
  }

  $records = db_query("SELECT DISTINCT type, id FROM {file_usage} WHERE fid = :fid AND type IN (:types) AND id > 0", array(':fid' => $file->fid, ':types' => $entity_types))->fetchAll();
  if (!empty($records)) {
    $cids = array();
    foreach ($records as $record) {
      $cids[] = 'field:' . $record->type . ':' . $record->id;
    }
    cache_clear_all($cids, 'cache_field');
  }
}

/**
 * Check if a file entity is considered local or not.
 *
 * @param object $file
 *   A file entity object from file_load().
 *
 * @return
 *   TRUE if the file is using a local stream wrapper, or FALSE otherwise.
 */
function file_entity_file_is_local($file) {
  $scheme = file_uri_scheme($file->uri);
  $wrappers = \Drupal::service('stream_wrapper_manager')->getWrappers(StreamWrapperInterface::LOCAL);
  return !empty($wrappers[$scheme]) && empty($wrappers[$scheme]['remote']);
}

/**
 * Check if a file entity is considered writeable or not.
 *
 * @param \Drupal\file\FileInterface $file
 *   A file entity object from file_load().
 *
 * @return
 *   TRUE if the file is using a visible, readable and writeable stream wrapper,
 *   or FALSE otherwise.
 */
function file_entity_file_is_writeable(FileInterface $file) {
  $scheme = file_uri_scheme($file->getFileUri());
  $wrappers = \Drupal::service('stream_wrapper_manager')->getWrappers(StreamWrapperInterface::WRITE_VISIBLE);
  return !empty($wrappers[$scheme]);
}

/**
 * @name pathauto_file Pathauto integration for the core file module.
 * @{
 */

/**
 * Implements hook_form_FORM_ID_alter() on behalf of pathauto.module.
 *
 * Add the Pathauto settings to the file form.
 */
function pathauto_form_file_entity_edit_alter(&$form, &$form_state, $form_id) {
  $file = $form_state['file'];
  $langcode = pathauto_entity_language('file', $file);
  pathauto_field_attach_form('file', $file, $form, $form_state, $langcode);
}

/**
 * Implements hook_file_operations() on behalf of pathauto.module.
 */
function pathauto_file_operations() {
  $operations['pathauto_update_alias'] = array(
    'label' => t('Update URL alias'),
    'callback' => 'pathauto_file_update_alias_multiple',
    'callback arguments' => array('bulkupdate', array('message' => TRUE)),
  );
  return $operations;
}

/**
 * Update action wrapper for pathauto_file_update_alias().
 */
function pathauto_file_update_action($file, $context = array()) {
  pathauto_file_update_alias($file, 'bulkupdate', array('message' => TRUE));
}

/**
 * @} End of "name pathauto_file".
 */

/**
 * Implements hook_form_FORM_ID_alter() for file_entity_edit() on behalf of path.module.
 */
function path_form_file_entity_edit_alter(&$form, $form_state) {
  // Make sure this does not show up on the delete confirmation form.
  if (empty($form_state['confirm_delete'])) {
    $file = $form_state['file'];
    $langcode = function_exists('entity_language') ? entity_language('file', $file) : NULL;
    $langcode = !empty($langcode) ? $langcode : LANGUAGE_NONE;
    $conditions = array('source' => 'file/' . $file->fid, 'language' => $langcode);
    $path = (isset($file->fid) ? path_load($conditions) : array());
    if ($path === FALSE) {
      $path = array();
    }
    $path += array(
      'pid' => NULL,
      'source' => isset($file->fid) ? 'file/' . $file->fid : NULL,
      'alias' => '',
      'language' => $langcode,
    );
    $form['path'] = array(
      '#type' => 'fieldset',
      '#title' => t('URL path settings'),
      '#collapsible' => TRUE,
      '#collapsed' => empty($path['alias']),
      '#group' => 'additional_settings',
      '#attributes' => array(
        'class' => array('path-form'),
      ),
      '#attached' => array(
        'js' => array(drupal_get_path('module', 'path') . '/path.js'),
      ),
      '#access' => user_access('create url aliases') || user_access('administer url aliases'),
      '#weight' => 30,
      '#tree' => TRUE,
      '#element_validate' => array('path_form_element_validate'),
    );
    $form['path']['alias'] = array(
      '#type' => 'textfield',
      '#title' => t('URL alias'),
      '#default_value' => $path['alias'],
      '#maxlength' => 255,
      '#description' => t('Optionally specify an alternative URL by which this file can be accessed. For example, type "about" when writing an about page. Use a relative path and don\'t add a trailing slash or the URL alias won\'t work.'),
    );
    $form['path']['pid'] = array('#type' => 'value', '#value' => $path['pid']);
    $form['path']['source'] = array('#type' => 'value', '#value' => $path['source']);
    $form['path']['language'] = array('#type' => 'value', '#value' => $path['language']);
  }
}

// @todo move
function file_entity_entity_base_field_info(EntityTypeInterface $entity_type) {
  // @todo: Make this configurable and/or remove if
  //   https://drupal.org/node/476294 is resolved.
  if (\Drupal::moduleHandler()->moduleExists('pathauto') && $entity_type->id() == 'file') {
    $fields = array();
    $fields['path'] = BaseFieldDefinition::create('path')
      ->setCustomStorage(TRUE)
      ->setLabel(t('URL alias'))
      ->setTranslatable(TRUE)
      ->setDisplayOptions('form', array(
        'type' => 'pathauto',
        'weight' => 30,
      ))
      ->setDisplayConfigurable('form', TRUE);
    return $fields;
  }
}

/**
 * Checks if pattern(s) match mimetype(s).
 */
function file_entity_match_mimetypes($needle, $haystack) {
  $needle = is_array($needle) ? $needle : array($needle);
  $haystack = is_array($haystack) ? $haystack : array($haystack);

  foreach ($haystack as $mimetype) {
    foreach ($needle as $search) {
      if (fnmatch($search, $mimetype) || fnmatch($mimetype, $search)) {
        return TRUE;
      }
    }
  }

  return FALSE;
}

/**
 * Return a Url for a file download.
 *
 * @param \Drupal\file\FileInterface $file
 *   The file to get a download url for.
 * @param array $options
 *   (optional) Options for the URL object.
 *
 * @return \Drupal\Core\Url
 *   An Url object for the download url.
 */
function file_entity_download_url($file, $options = array()) {
  $url = new Url('file_entity.file_download', array('file' => $file->id()), $options);
  if (!\Drupal::config('file_entity.settings')->get('allow_insecure_download')) {
    $url->setOption('query', array('token' => file_entity_get_download_token($file)));
  }
  return $url;
}

function file_entity_file_get_mimetype_type(FileInterface $file) {
  list($type, $subtype) = explode('/', $file->getMimeType(), 2);
  return $type;
}

/**
 * Implements hook_admin_menu_map().
 */
function file_entity_admin_menu_map() {
  if (!user_access('administer file types')) {
    return;
  }
  $map['admin/structure/file-types/manage/%file_type'] = array(
    'parent' => 'admin/structure/file-types',
    'arguments' => array(
      array('%file_type' => array_keys(file_entity_type_get_names())),
    ),
  );
  return $map;
}

/**
 * Generates a token to protect a file download URL.
 *
 * This prevents unauthorized crawling of all file download URLs since the
 * {file_managed}.fid column is an auto-incrementing serial field and is easy
 * to guess or attempt many at once. This can be costly both in CPU time
 * and bandwidth.
 *
 * @see image_style_path_token()
 *
 * @param object $file
 *   A file entity object.
 *
 * @return string
 *   An eight-character token which can be used to protect file downloads
 *   against denial-of-service attacks.
 */
function file_entity_get_download_token(File $file) {
  // Return the first eight characters.
  return substr(\Drupal\Component\Utility\Crypt::hmacBase64(
    "file/{$file->id()}/download:" . $file->getFileUri(),
    \Drupal::service('private_key')->get() . \Drupal\Core\Site\Settings::getHashSalt()
  ), 0, 8);
}

/**
 * Find all fields that are of a certain field type.
 *
 * @param string $field_type
 *   A field type.
 *
 * @return array
 *   An array of field names that match the type $field_type.
 */
function _file_entity_get_fields_by_type($field_type) {
  $return = array();
  if (function_exists('field_info_field_map')) {
    foreach (field_info_field_map() as $field_name => $field) {
      if ($field['type'] == $field_type) {
        $return[$field_name] = $field_name;
      }
    }
  }
  else {
    foreach (field_info_fields() as $field_name => $field) {
      if ($field['type'] == $field_type) {
        $return[$field_name] = $field_name;
      }
    }
  }
  return $return;
}

/**
 * Implements hook_entity_storage_load().
 */
function file_entity_entity_storage_load($entities, $entity_type) {
  // Loop over all the entities looking for entities with attached images.
  foreach ($entities as $entity) {
    /** @var \Drupal\Core\Entity\ContentEntityInterface $entity */
    // Examine every image field instance attached to this entity's bundle.
    foreach ($entity->getFieldDefinitions() as $field_definition) {
      if ($field_definition->getSetting('target_type') == 'file' && $field_definition->getType() != 'image') {
        $field_name = $field_definition->getName();
        if (!empty($entity->{$field_name})) {
          foreach ($entity->$field_name as $delta => $item) {
            // If alt and title text is not specified, fall back to alt and
            // title text on the file.
            if (!empty($item->target_id) && (empty($item->alt) || empty($item->title))) {
              $file = $item->entity;
              foreach (array('alt', 'title') as $key) {
                if (empty($item->$key) && !empty($file->{$key})) {
                  $item->key = $file->$key;
                }
              }
            }
          }
        }
      }
    }
  }

}

function file_entity_get_public_and_private_stream_wrapper_names($flag = StreamWrapperInterface::VISIBLE) {
  $wrappers = array('public' => [], 'private' => []);
  // @todo Make the set of private schemes/stream wrappers extendable.
  $private_schemes = ['private', 'temporary'];
  foreach (\Drupal::service('stream_wrapper_manager')->getWrappers($flag) as $key => $wrapper) {
    // Some wrappers, e.g. those set in KernelTestBase, do not provide a name.
    $wrapper_name = isset($wrapper['name']) ? $wrapper['name'] : substr(strrchr($wrapper['class'], '\\'), 1);
    if (in_array($key, $private_schemes)) {
      $wrappers['private'][$key] = $wrapper_name;
    }
    else {
      $wrappers['public'][$key] = $wrapper_name;
    }
  }
  return $wrappers;
}


/**
 * Implements hook_file_load().
 */
function file_entity_file_load($files) {
//  $alt = variable_get('file_entity_alt', '[file:field_file_image_alt_text]');
//  $title = variable_get('file_entity_title', '[file:field_file_image_title_text]');

  $alt = '[file:field_image_alt_text]';
  $title = '[file:field_image_title_text]';


  $replace_options = array(
    'clear' => TRUE,
    'sanitize' => FALSE,
  );

  /** @var \Drupal\Core\Utility\Token::replace $token_service */
  $token_service = \Drupal::service('token');

  /** @var \Drupal\file_entity\Entity\FileEntity $file */
  foreach ($files as $file) {
    $file->metadata = array();

    // Load alt and title text from fields.
    if (!empty($alt)) {
      $token_bubbleable_metadata = new BubbleableMetadata();
      $file->alt = $token_service->replace($alt, array('file' => $file), $replace_options, $token_bubbleable_metadata);
      // Add the cacheability metadata of the token to the file entity. This
      // means attachments are discarded, but it does not ever make sense to
      // have attachments for an image's "alt" attribute anyway, so this is
      // acceptable.
      $file->addCacheableDependency($token_bubbleable_metadata);
    }
    if (!empty($title)) {
      $token_bubbleable_metadata = new BubbleableMetadata();
      $file->title = $token_service->replace($title, array('file' => $file), $replace_options, $token_bubbleable_metadata);
      // Similar to the above, but for the "title" attribute.
      $file->addCacheableDependency($token_bubbleable_metadata);
    }
  }

  // Load and unserialize metadata.
  $results = db_query("SELECT * FROM {file_metadata} WHERE fid IN (:fids[])", array(':fids[]' => array_keys($files)));
  foreach ($results as $result) {
    $files[$result->fid]->metadata[$result->name] = unserialize($result->value);
  }
}
